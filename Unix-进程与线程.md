# Linux学习笔记
## Linux操作系统结构
Linux操作系统的结构从底层到上层分为四层，分别是硬件系统驱动层、操作系统内核层、操作系统服务层和用户应用程序层。其中硬件系统驱动层管理底层硬件的驱动，内核层负责Linux的文件系统管理、进程管理、内存管理和驱动管理。服务层就是一个让用户应用程序和内核进行通信的平台，提供系统调用的功能。一些系统调用函数如sys_read, sys_write, sys_call等都属于服务层。最上层就是用户应用程序层，对应的就是软件工程师写的应用程序，如C++，Java等。图示如下：  
![a](https://i.loli.net/2021/08/19/E4Xx2co1DjkwQCt.png)  
当一个应用程序执行时，遇见系统调用会将Linux从用户态切换到内核态，然后在kernel层执行。当需要对硬件进行操作的时候kernel负责对其操作。执行完毕后，再重新回到用户态。  
那么什么是用户态和内核态呢？用户态就是执行着用户程序、标准库或者SDK时所处的状态，内核态就是执行系统调用Linux所处的状态。  
## Linux内核
Linux内核所处上图的第三层。总的来说内核分为进程调度模块、内存管理模块、文件系统模块、进程间通信模块和驱动管理模块。各个模块相互关联，比如内存管理模块会和进程调度模块会相关联。 
## Linux中断机制
Linux的中断机制的目的是为了处理一些情况，比如硬件的中断响应、系统调用的响应、信号响应和系统异常错误的处理等。  
中断分硬件中断和软件中断。硬中断由硬件中断控制芯片发出。软件中断分为两类，由CPU自行保留的中断和系统调用。代码在kernel中的asm.s traps.c system_call.s fork.c signal.c exit.c system.c中找到。  
Linux中断的执行流程为：  
1. 将寄存器、异常码(中断号)、当前函数返回值入栈
2. 调用中断服务函数
3. 出栈函数返回值、寄存器值  

中断前的处理和返回过程由asm.s和system_call.s处理，中断的执行过程由trap.c, fork.c, signal.c, exit.c, sys.c处理。asm.s对应硬件中断，system_call.s对应软件及系统调用处理过程。   
入栈和出栈的操作由汇编实现，处理中段的函数由C语言实现。

## Process
Process is a Process, in Linux, is a struct called task_struct
